# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/dashboards.ipynb (unless otherwise specified).

__all__ = ['TrainValRecordsComparison']

# Cell
from bokeh.plotting import show, output_notebook
from bokeh.models.widgets import DataTable, TableColumn
from bokeh.models import ColumnDataSource

import panel as pn
import panel.widgets as pnw
import pandas as pd

from .utils import *
from .components import *

# Cell
class TrainValRecordsComparison:
    """
    Dashboard to compare the generated train and val records, to ensure the don't diverge to much from each other.
    """
    def __init__(self, train_records, val_records, class_map=None):
        self.train_records = train_records
        self.val_records = val_records
        self.class_map = class_map
        self.data = self._aggregate_data()

    def _aggregate_data(self):
        """Aggregates data from train and val records into a dataframe"""
        train_data = aggregate_record_data(self.train_records)
        val_data = aggregate_record_data(self.val_records)
        train_data = pd.DataFrame(train_data)
        val_data = pd.DataFrame(val_data)
        train_data["type"] = "train"
        val_data["type"] = "val"
        full_data = pd.concat([val_data, train_data])
        # convert the label column to the corrosponding names if a class_map is present and shift the previous labels to a label_num column
        # use the label column for here on generically
        if self.class_map is not None:
            full_data["label_num"] = full_data["label"]
            full_data["label"] = full_data["label"].apply(self.class_map.get_id)
        return full_data

    def _collect_stat(self):
        """Calculates stats on the aggregated data for the two datasets sets and returns them as a dataframe."""
        train_stats = {}
        val_stats = {}
        deviation_stats = {}
        # collect stats
        grouping = self.data.groupby("type")
        train_group = grouping.get_group("train")
        val_group = grouping.get_group("val")
        train_label_fractions = train_group.value_counts("label") / train_group.shape[0]
        val_label_fractions = val_group.value_counts("label") / val_group.shape[0]
        for key, value in val_label_fractions.items():
            val_stats["label_fraction_"+key] = value
        for key, value in train_label_fractions.items():
            train_stats["label_fraction_"+key] = value
        val_stats["area_min"] = val_group["area"].min()
        val_stats["area_max"] = val_group["area"].max()
        val_stats["area_avg"] = val_group["area"].mean()
        val_stats["area_std"] = val_group["area"].std()
        train_stats["area_min"] = train_group["area"].min()
        train_stats["area_max"] = train_group["area"].max()
        train_stats["area_avg"] = train_group["area"].mean()
        train_stats["area_std"] = train_group["area"].std()

        # calculated deviations dict
        for key, value in train_stats.items():
            deviation_stats[key] = 1-val_stats[key]/value
        # convert the dicts to dfs
        train_stats = pd.DataFrame(train_stats, index=["train"])
        val_stats = pd.DataFrame(val_stats, index=["val"])
        deviation_stats = pd.DataFrame(deviation_stats, index=["deviation (1-val/train)"])
        data = pd.concat([train_stats, val_stats, deviation_stats]).T
        data = data.round(2)
        data = data.reset_index()
        data["index"] = data["index"].apply(lambda x: x.replace("_", " ").title())
        return data

    def comparison_table(self, width=600, height=600):
        """Generates a table that compares stats between train and val datasets."""
        data = self._collect_stat()
        source = ColumnDataSource(data)

        columns = [TableColumn(field=filed, title=filed.replace("_", " ").title()) for filed in data.columns]
        data_table = DataTable(source=source, columns=columns, width=width, height=height)
        return data_table

    def area_histogram(self, width=500, height=500):
        """Generates area histogram for the train and val dataset."""
        return histogram_with_gui([group[1] for group in self.data.groupby("type")], hist_func=area_histogram, width=width, height=height)

    def show(self):
        table = self.comparison_table(width=600, height=250)
        area_histogram = self.area_histogram(width=600, height=500)

        return pn.Column(table, area_histogram)