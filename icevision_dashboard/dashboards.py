# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/dashboards.ipynb (unless otherwise specified).

__all__ = ['DatasetOverview', 'DatasetFilter', 'TrainValRecordsComparison']

# Cell
from typing import Union

from bokeh.plotting import show, output_notebook
from bokeh.models.widgets import DataTable, TableColumn
from bokeh.models import ColumnDataSource

import panel as pn
import panel.widgets as pnw
import pandas as pd

from .utils import *
from .components import *

# Cell
class DatasetOverview:
    def __init__(self, records, class_map=None, height=500, width=1500):
        self.records = records
        self.class_map = class_map
        self.data = pd.DataFrame(aggregate_record_data(records, class_map))
        self.height = height
        self.width = width

    def _generate_dataset_tab(self):
        overview_table = table_from_dataframe(self.data, width=self.width, height=self.height)

        return pn.Column(overview_table)

    def _generate_image_tab(self):
        overview_table = table_from_dataframe(image_stats(self.data), width=self.width, height=50)
        img_gallery = gallery(self.records, self.class_map, height=self.height-20)

        return pn.Column(pn.Row(overview_table, align="center"), pn.Row(img_gallery, align="center"))

    def _generate_class_tab(self):
        overview_table = table_from_dataframe(class_stats(self.data), height=150)
        mixing_matrix_df, mapping = get_mixing_matrix(self.data, mixing_col="filepath", mixing_objects="label")
        mixing_histogram = histogram_2d(mixing_matrix_df, "row_name", "col_name", "values", height=self.height-150)

        return pn.Column(pn.Row(overview_table, align="center"), pn.Row(mixing_histogram, align="center"), align="center")

    def show(self):
        dataset_tab = self._generate_dataset_tab()
        image_tab = self._generate_image_tab()
        class_tab = self._generate_class_tab()

        return pn.Tabs(("Dataset overview", dataset_tab), ("Image stats", image_tab), ("Class stats", class_tab))

# Cell
class DatasetFilter:
    """Creates a gallery with filter options to select subsets of the data. If the export_varialbe is set to a variable, that is a list a dict with the current selection (pd.Dataframe (key: data) and list of records (key: records)) will be append to the list."""
    def __init__(self, records, class_map=None, export_variable: Union[list, None] = None, height=500, width=500):
        self.records = records
        self.class_map = class_map
        self.export_variable = export_variable
        self.width = width
        self.height = height

        self.inner_width = int(0.97*width)
        self.data = aggregate_record_data(records, class_map)

        self.filters = []

    @staticmethod
    def _get_mask_from_range(values, selections):
        return (values >= selections[0]) & (values < selections[1])

    def show(self):
        """Creates a gallery with filter options to select subsets of the data. If the export_varialbe is set to a variable, that is a list a dict with the current selection (pd.Dataframe (key: data) and list of records (key: records)) will be append to the list."""
        # generate bbox filters
        options = self.data["label"].unique()
        options.sort()
        bbox_class_filter = pnw.MultiSelect(name="Class", options=options.tolist(), value=options.tolist())
        bbox_num_annotations_filter = generate_range_filter(self.data["num_annotations"], "Num. Annotations", steps=self.data["num_annotations"].max()+3)
        bbox_area_filter = generate_range_filter(self.data["area"], "Area", steps=10)
        bbox_width_filter = generate_range_filter(self.data["bbox_width"], "Bbox width", steps=10)
        bbox_height_filter = generate_range_filter(self.data["bbox_height"], "Bbbox height", steps=10)
        bbox_ratio_filter = generate_range_filter(self.data["bbox_ratio"], "Ratio", steps=10)
        annotation_filters = pn.Card(bbox_class_filter, bbox_num_annotations_filter, bbox_area_filter, bbox_width_filter, bbox_height_filter, bbox_ratio_filter, header="<h2>Bbox Filters</h2>", width=int(0.98*self.width), collapsed=True)

        # generate image filters
        file_creation_modification_time_filter = generate_creation_modification_time_filter(self.data, width=int(0.99*self.width))
        file_width_filter = generate_range_filter(self.data["width"], "Width", steps=10, width=int(0.99*self.width))
        file_height_filter = generate_range_filter(self.data["height"], "Height", steps=10, width=int(0.99*self.width))
        file_filters = pn.Card(file_creation_modification_time_filter, file_width_filter, file_height_filter, header="<h2>Image Filters</h2>", width=int(0.98*self.width), collapsed=True)

        filters = pn.Card(pn.Column(file_filters, annotation_filters), header="<h1>Filters</h1>", width=self.width, collapsed=True)

        def get_filtered_records_and_data():
            filtered_data = self.data[
                self.data["label"].isin(bbox_class_filter.value)
                & self._get_mask_from_range(self.data["num_annotations"], bbox_num_annotations_filter[0].value)
                & self._get_mask_from_range(self.data["area"], bbox_area_filter[0].value)
                & self._get_mask_from_range(self.data["bbox_width"], bbox_width_filter[0].value)
                & self._get_mask_from_range(self.data["bbox_height"], bbox_height_filter[0].value)
                & self._get_mask_from_range(self.data["bbox_ratio"], bbox_ratio_filter[0].value)
                & self._get_mask_from_range(self.data["creation_date"], file_creation_modification_time_filter[1].value)
                & self._get_mask_from_range(self.data["modification_date"], file_creation_modification_time_filter[2].value)
                & self._get_mask_from_range(self.data["width"], file_width_filter[0].value)
                & self._get_mask_from_range(self.data["height"], file_height_filter[0].value)
            ]
            filtered_records = [self.records[i] for i in filtered_data["record_index"].unique()]
            return filtered_records, filtered_data

        @pn.depends(
            bbox_class_filter.param.value, bbox_num_annotations_filter[0].param.value_throttled, bbox_area_filter[0].param.value_throttled,
            bbox_width_filter[0].param.value_throttled, bbox_height_filter[0].param.value_throttled, bbox_ratio_filter[0].param.value_throttled,
            file_creation_modification_time_filter[1].param.value_throttled, file_creation_modification_time_filter[2].param.value_throttled,
            file_width_filter[0].param.value_throttled, file_height_filter[0].param.value_throttled
        )
        def _gallery(
            classes_selection, num_annotation_selection, area_selection, width_selection, height_selection, ratio_selection,
            image_creation_date_selection, image_modification_date_selection, image_with_selection, image_height_selection
        ):
            filtered_records, filtered_data = get_filtered_records_and_data()

            # update filter histograms
            bbox_num_annotations_filter[1] = histogram(self.data.groupby("id").count()["width"], bins=20, height=100, width=int(self.width*0.97), range=(self.data.groupby("id").count()["width"].min(), self.data.groupby("id").count()["width"].max()), remove_tools=True)
            bbox_area_filter[1] = histogram(filtered_data["area"], bins=20, height=100, width=int(self.width*0.97), range=(self.data["area"].min(), self.data["area"].max()), remove_tools=True)
            bbox_width_filter[1] = histogram(filtered_data["bbox_width"], bins=20, height=100, width=int(self.width*0.97), range=(self.data["bbox_width"].min(), self.data["bbox_width"].max()), remove_tools=True)
            bbox_height_filter[1] = histogram(filtered_data["bbox_height"], bins=20, height=100, width=int(self.width*0.97), range=(self.data["bbox_height"].min(), self.data["bbox_height"].max()), remove_tools=True)
            bbox_ratio_filter[1] = histogram(filtered_data["bbox_ratio"], bins=20, height=100, width=int(self.width*0.97), range=(self.data["bbox_ratio"].min(), self.data["bbox_ratio"].max()), remove_tools=True)

            if len(filtered_records) == 0:
                return None
            else:
                return gallery(filtered_records)

        if self.export_variable is not None:
            def export(event):
                filtered_records, filtered_data = get_filtered_records_and_data()
                self.export_variable.append({"data": filtered_data, "records": filtered_records})

            export_button = pnw.Button(name="Export")
            export_button.on_click(export)

            return pn.Column(pn.Row(filters, align="center"), _gallery, export_button, align="center")
        else:
            return pn.Column(pn.Row(filters, align="center"), _gallery, align="center")

# Cell
class TrainValRecordsComparison:
    """
    Dashboard to compare the generated train and val records, to ensure the don't diverge to much from each other.
    """
    def __init__(self, train_records, val_records, class_map=None):
        self.train_records = train_records
        self.val_records = val_records
        self.class_map = class_map
        self.data = self._aggregate_data()

    def _aggregate_data(self):
        """Aggregates data from train and val records into a dataframe"""
        train_data = aggregate_record_data(self.train_records)
        val_data = aggregate_record_data(self.val_records)
        train_data["type"] = "train"
        val_data["type"] = "val"
        full_data = pd.concat([val_data, train_data])
        # convert the label column to the corrosponding names if a class_map is present and shift the previous labels to a label_num column
        # use the label column for here on generically
        if self.class_map is not None:
            full_data["label_num"] = full_data["label"]
            full_data["label"] = full_data["label"].apply(self.class_map.get_id)
        return full_data

    def _collect_stat(self):
        """Calculates stats on the aggregated data for the two datasets sets and returns them as a dataframe."""
        train_stats = {}
        val_stats = {}
        deviation_stats = {}
        # collect stats
        grouping = self.data.groupby("type")
        train_group = grouping.get_group("train")
        val_group = grouping.get_group("val")
        train_label_fractions = train_group.value_counts("label") / train_group.shape[0]
        val_label_fractions = val_group.value_counts("label") / val_group.shape[0]
        for key, value in val_label_fractions.items():
            val_stats["label_fraction_"+key] = value
        for key, value in train_label_fractions.items():
            train_stats["label_fraction_"+key] = value
        val_stats["area_min"] = val_group["area"].min()
        val_stats["area_max"] = val_group["area"].max()
        val_stats["area_avg"] = val_group["area"].mean()
        val_stats["area_std"] = val_group["area"].std()
        train_stats["area_min"] = train_group["area"].min()
        train_stats["area_max"] = train_group["area"].max()
        train_stats["area_avg"] = train_group["area"].mean()
        train_stats["area_std"] = train_group["area"].std()

        # calculated deviations dict
        for key, value in train_stats.items():
            deviation_stats[key] = 1-val_stats[key]/value
        # convert the dicts to dfs
        train_stats = pd.DataFrame(train_stats, index=["train"])
        val_stats = pd.DataFrame(val_stats, index=["val"])
        deviation_stats = pd.DataFrame(deviation_stats, index=["deviation (1-val/train)"])
        data = pd.concat([train_stats, val_stats, deviation_stats]).T
        data = data.round(2)
        data = data.reset_index()
        data["index"] = data["index"].apply(lambda x: x.replace("_", " ").title())
        return data

    def comparison_table(self, width=600, height=600):
        """Generates a table that compares stats between train and val datasets."""
        data = self._collect_stat()
        source = ColumnDataSource(data)

        columns = [TableColumn(field=filed, title=filed.replace("_", " ").title()) for filed in data.columns]
        data_table = DataTable(source=source, columns=columns, width=width, height=height)
        return data_table

    def area_histogram(self, width=500, height=500):
        """Generates area histogram for the train and val dataset."""
        return comparison_histogram_with_gui([group[1] for group in self.data.groupby("type")], hist_func=area_histogram, width=width, height=height)

    def show(self):
        table = self.comparison_table(width=600, height=250)
        area_histogram = self.area_histogram(width=600, height=500)

        return pn.Column(table, area_histogram)