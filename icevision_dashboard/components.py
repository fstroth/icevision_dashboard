# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/components.ipynb (unless otherwise specified).

__all__ = ['gallery', 'filtered_gallery', 'barplot_class_occurance', 'area_histogram', 'histogram_with_gui']

# Cell
from typing import Optional

from icevision.core.class_map import ClassMap

import panel as pn
import panel.widgets as pnw
from bokeh.plotting import figure
import numpy as np
import pandas as pd

from .utils import *

# Cell
def gallery(
    records,
    class_map: Optional[ClassMap] = None,
    display_label: bool = True,
    display_bbox: bool = True,
    display_mask: bool = True,
    display_keypoints: bool = True,
):
    """Shows a gallery for a list of records."""
    # gui
    btn_prev = pnw.Button(name="<")
    btn_next = pnw.Button(name=">")
    current = pnw.TextInput(value="1")
    overall = pn.Row("/" + str(len(records)))
    gui = pn.Row(btn_prev, current, overall, btn_next, align="center")

    # plotting function
    @pn.depends(current.param.value)
    def _plot(_):
        nonlocal current
        try:
            index = int(current.value) - 1
        except:
            pass
        img  = draw_record_with_bokeh(
            record=records[index],
            class_map=class_map,
            display_label=display_label,
            display_bbox=display_bbox,
            display_mask=display_mask,
            display_keypoints=display_keypoints,
            return_figure=True,
        )
        return img

    # add interactions
    def _next(_):
        nonlocal current
        nonlocal records
        try:
            index = int(current.value)
            if index == len(records):
                index = 1
            else:
                index += 1
            current.value = str(index)
        except:
            pass


    def _previous(_):
        nonlocal current
        nonlocal records
        try:
            index = int(current.value)
            if index == 1:
                index = len(records)
            else:
                index -= 1
            current.value = str(index)
        except:
            pass

    btn_prev.on_click(_previous)
    btn_next.on_click(_next)

    return pn.Column(gui, pn.Row(_plot, align="center"))

# Cell
def filtered_gallery(records, class_map=None, export_variable=None, height=500, width=500):
    inner_width = int(0.97*width)
    data = aggregate_record_data(records)
    data = pd.DataFrame(data)

    if class_map is not None:
        data["label_num"] = data["label"]
        data["label"] = data["label"].apply(class_map.get_id)

    # generate bbox filters
    options = data["label"].unique()
    options.sort()
    bbox_class_filter = pnw.MultiSelect(name="Class", options=options.tolist(), value=options.tolist())
    bbox_num_annotations_filter = generate_range_filter(data["num_annotations"], "Num. Annotations", steps=data["num_annotations"].max()+3)
    bbox_area_filter = generate_range_filter(data["area"], "Area", steps=10)
    bbox_width_filter = generate_range_filter(data["bbox_width"], "Bbox width", steps=10)
    bbox_height_filter = generate_range_filter(data["bbox_height"], "Bbbox height", steps=10)
    bbox_ratio_filter = generate_range_filter(data["bbox_ratio"], "Ratio", steps=10)
    annotation_filters = pn.Card(bbox_class_filter, bbox_num_annotations_filter, bbox_area_filter, bbox_width_filter, bbox_height_filter, bbox_ratio_filter, header="<h2>Bbox Filters</h2>", width=int(0.98*width), collapsed=True)

    # generate image filters
    file_creation_modification_time_filter = generate_creation_modification_time_filter(data, width=int(0.99*width))
    file_width_filter = generate_range_filter(data["width"], "Width", steps=10, width=int(0.99*width))
    file_height_filter = generate_range_filter(data["height"], "Height", steps=10, width=int(0.99*width))
    file_filters = pn.Card(file_creation_modification_time_filter, file_width_filter, file_height_filter, header="<h2>Image Filters</h2>", width=int(0.98*width), collapsed=True)

    filters = pn.Card(pn.Column(file_filters, annotation_filters), header="<h1>Filters</h1>", width=width, collapsed=True)

    @pn.depends(
        bbox_class_filter.param.value, bbox_num_annotations_filter[0].param.value, bbox_area_filter[0].param.value, bbox_width_filter[0].param.value, bbox_height_filter[0].param.value, bbox_ratio_filter[0].param.value,
        file_creation_modification_time_filter[1], file_creation_modification_time_filter[2], file_width_filter[0], file_height_filter[0]
    )
    def _gallery(classes_selection, num_annotation_selection, area_selection, width_selection, height_selection, ratio_selection, image_creation_date_selection, image_modification_date_selection, image_with_selection, image_height_selection):
        nonlocal data
        nonlocal bbox_class_filter
        nonlocal bbox_num_annotations_filter
        nonlocal bbox_area_filter
        nonlocal bbox_width_filter
        nonlocal bbox_height_filter
        nonlocal bbox_ratio_filter
        nonlocal file_creation_modification_time_filter
        nonlocal file_width_filter
        nonlocal file_height_filter

        range_mask = lambda values, selections: (values >= selections[0]) & (values < selections[1])

        # generate gallery
        filtered_data = data[
            (data["label"].isin(classes_selection))
            & range_mask(data["num_annotations"], num_annotation_selection)
            & range_mask(data["area"], area_selection)
            & range_mask(data["bbox_width"], width_selection)
            & range_mask(data["bbox_height"], height_selection)
            & range_mask(data["bbox_ratio"], ratio_selection)
            & range_mask(data["creation_date"], image_creation_date_selection)
            & range_mask(data["modification_date"], image_modification_date_selection)
            & range_mask(data["width"], image_with_selection)
            & range_mask(data["height"], image_height_selection)
        ]
        filtered_records = [records[i] for i in filtered_data["record_index"].unique()]

        # update filter histograms
        bbox_num_annotations_filter[1] = histogram(data.groupby("id").count()["width"], bins=20, height=100, width=int(width*0.97), range=(data.groupby("id").count()["width"].min(), data.groupby("id").count()["width"].max()), remove_tools=True)
        bbox_area_filter[1] = histogram(filtered_data["area"], bins=20, height=100, width=int(width*0.97), range=(data["area"].min(), data["area"].max()), remove_tools=True)
        bbox_width_filter[1] = histogram(filtered_data["bbox_width"], bins=20, height=100, width=int(width*0.97), range=(data["bbox_width"].min(), data["bbox_width"].max()), remove_tools=True)
        bbox_height_filter[1] = histogram(filtered_data["bbox_height"], bins=20, height=100, width=int(width*0.97), range=(data["bbox_height"].min(), data["bbox_height"].max()), remove_tools=True)
        bbox_ratio_filter[1] = histogram(filtered_data["bbox_ratio"], bins=20, height=100, width=int(width*0.97), range=(data["bbox_ratio"].min(), data["bbox_ratio"].max()), remove_tools=True)

        if len(filtered_records) == 0:
            return None
        else:
            return gallery(filtered_records)
    return pn.Column(pn.Row(filters, align="center"), _gallery, align="center")

# Cell
def barplot_class_occurance(record_stats, class_map=None, width=500, height=500):
    """Creates a barplot of the class occurances."""
    result = record_stats.groupby("label").count()["id"]
    counts, values = result.values, result.index.tolist()
    # sort result in decending order
    fig = draw_class_based_barplot(counts, values, class_map=class_map, width=width, height=height)
    return pn.Column(fig)

# Cell
def area_histogram(record_stats, class_label, class_map=None, bins=10, normalized=False, density=False, range=None, width=500, height=500):
    """Creates a histogram for a given class_label from record_stats."""
    if normalized:
        df_col = "area_normalized"
        x_label = "Area (normalized)"
    else:
        df_col = "area"
        x_label = "Area"
    if class_map is not None:
        key = class_map.get_id(class_label)
        title = f"{class_map.get_id(class_label)}: {record_stats[record_stats['label'] == class_label].size} objects"
    else:
        title = f"{class_label}: {record_stats[record_stats['label'] == class_label].size} objects"

    p = figure(width=width, height=height, x_axis_label = x_label, y_axis_label = "No. annotations", title=title)
    p = histogram(record_stats[record_stats["label"] == class_label][df_col].values, density=density, bins=bins, range=range, plot_figure=p, width=500, height=500)
    return p

# Cell
def histogram_with_gui(record_stats_list, hist_func, class_map=None, width=500, height=500):
    """Creates histograms for a list of record_stats and a histogram function (based on the histogram function from utils) with a full gui to customize the histogram parameters.
    The hist function must have the following call head: (record_stats, class_label, class_map, bins, normalized, density, range, width, height)"""
    # gui
    # remove the first entry from the class_map, because the background class is not explicit part of the annotaitons
    unique_labels = sorted(pd.unique(record_stats_list[0]["label"]))
    for record_stats in record_stats_list[1:]:
        if not all(pd.unique(sorted(record_stats["label"])) == unique_labels):
            raise ValueError("All dataframes in the records_stats_list need to have the same set of unique values.")
    options = pd.unique(record_stats_list[0]["label"])
    options.sort()
    if class_map is not None:
        options = np.vectorize(class_map.get_id)(options)
    class_dropdown = pnw.Select(options=options.tolist())

    bins_slider = pnw.IntSlider(name="Bins", start=10, end=100, step=5)
    checkbox_normalized = pnw.Checkbox(name="Normalized", value=False)
    checkbox_density = pnw.Checkbox(name="Density", value=False)

    range_min = int(min(record_stats["area"].min() for record_stats in record_stats_list))
    range_max = int(max(record_stats["area"].max() for record_stats in record_stats_list))
    steps = (range_max-range_min)/50
    range_slider = pnw.RangeSlider(name="Range", start=range_min, end=range_max, step=steps)

    @pn.depends(class_dropdown.param.value, bins_slider.param.value, checkbox_normalized.param.value, checkbox_density.param.value, range_slider.param.value)
    def _draw_histogram(class_label, bins, normalized, density, range):
        nonlocal class_map
        nonlocal width
        nonlocal height
        nonlocal record_stats_list
        class_label = class_label if class_map is None else class_map.get_name(class_label)
        # make the range slider dynamic with respect to the normalization
        if normalized:
            if range_slider.end != 1:
                old_slider_end = range_slider.end
                old_slider_start = range_slider.start
                range_slider.start = 0
                range_slider.end = 1
                range_slider.step = 1/50
                range_slider.value = ((range_slider.value[0]-old_slider_start)/(old_slider_end-old_slider_start), (range_slider.value[1]-old_slider_start)/(old_slider_end-old_slider_start))
                range = range_slider.value
        else:
            if range_slider.end != int(max(record_stats["area"].max() for record_stats in record_stats_list)):
                range_slider.start = int(min(record_stats["area"].min() for record_stats in record_stats_list))
                range_slider.end = int(max(record_stats["area"].max() for record_stats in record_stats_list))
                range_slider.step = (range_max-range_min)/50
                range_slider.value = ((range_slider.value[0]*(range_slider.end-range_slider.start))+range_slider.start, (range_slider.value[1]*(range_slider.end-range_slider.start))+range_slider.start)
                range = range_slider.value
        return pn.Row(*[hist_func(record_stats, class_label, class_map=class_map, bins=bins, normalized=normalized, density=density, range=range, width=width, height=height) for record_stats in record_stats_list])

    return pn.Column(class_dropdown, pn.Row(bins_slider, checkbox_normalized), pn.Row(range_slider, checkbox_density), _draw_histogram)