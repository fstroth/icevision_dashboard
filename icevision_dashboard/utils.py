# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/utils.ipynb (unless otherwise specified).

__all__ = ['aggregate_record_data', 'convert_rgb_image_to_bokeh_rgb_image', 'draw_record_with_bokeh',
           'draw_class_based_barplot', 'histogram', 'time_arc_plot', 'generate_range_filter', 'get_min_and_max_dates',
           'generate_creation_modification_time_filter']

# Cell
import datetime

import numpy as np
from bokeh.plotting import figure, show
import panel as pn
import panel.widgets as pnw
import pandas as pd

from icevision.visualize.draw_data import draw_record, draw_pred
from icevision.core.class_map import ClassMap

# Cell
def aggregate_record_data(records):
    """Aggregates stats from a list of records and returns a pandas dataframe with the aggregated stats. The creation time is not necessarily the real creation time.
    This depends on the OS, for more information see: https://docs.python.org/3/library/os.html#os.stat_result."""
    data = []
    for index,record in enumerate(records):
        for label, bbox in zip(record["labels"], record["bboxes"]):
            file_stats = record["filepath"].stat()
            bbox_widht = bbox.xmax - bbox.xmin
            bbox_height = bbox.ymax - bbox.ymin
            area = bbox_widht * bbox_height
            area_normalized = area / (record["width"] * record["height"])
            bbox_ratio = bbox_widht / bbox_height
            data.append(
                {
                    "id": record["imageid"], "width": record["width"], "height": record["height"], "label": label, "bbox_xmin": bbox.xmin,
                    "bbox_xmax": bbox.xmax, "bbox_ymin": bbox.ymin, "bbox_ymax": bbox.ymax, "area": area, "area_normalized": area_normalized,
                    "bbox_ratio": bbox_ratio, "record_index": index, "bbox_width": bbox_widht, "bbox_height": bbox_height, "filepath": record["filepath"],
                    "creation_date": datetime.datetime.fromtimestamp(file_stats.st_ctime), "modification_date": datetime.datetime.fromtimestamp(file_stats.st_mtime),
                    "num_annotations": len(record["bboxes"])
                }
            )
    return data

# Cell
def convert_rgb_image_to_bokeh_rgb_image(img: np.ndarray):
    """Convertes a image in the form of a numpy array to an array that can be shown by bokeh."""
    img = np.flipud(img)
    img = img.astype(np.uint8)
    bokeh_img = np.empty((img.shape[0],img.shape[1]), dtype=np.uint32)
    view = bokeh_img.view(dtype=np.uint8).reshape((img.shape[0],img.shape[1], 4))
    view[:,:, 0] = img[:,:,0]
    view[:,:, 1] = img[:,:,1]
    view[:,:, 2] = img[:,:,2]
    view[:,:, 3] = 255
    return bokeh_img

# Cell
def draw_record_with_bokeh(
    record,
    class_map=None,
    display_label=True,
    display_bbox=False,
    display_mask=False,
    display_keypoints=False,
    return_figure=False,
):
    """Draws a record or returns a bokeh figure containing the image."""
    img = draw_record(
            record=record,
            class_map=class_map,
            display_label=display_label,
            display_bbox=display_bbox,
            display_mask=display_mask,
            display_keypoints=display_keypoints,
        )

    # create bokeh figure with the plot
    bokeh_img = convert_rgb_image_to_bokeh_rgb_image(img)

    p = figure(tools="hover, reset, wheel_zoom, box_zoom, save, pan", plot_width=img.shape[1], plot_height=img.shape[0], x_range=(0, img.shape[1]), y_range=(img.shape[0], 0), x_axis_location="above")
    p.xgrid.grid_line_color = None
    p.ygrid.grid_line_color = None
    p.image_rgba([bokeh_img], x=0, y=img.shape[0], dw=img.shape[1], dh=img.shape[0], level="image")
    if return_figure:
        return p
    else:
        show(p)

# Cell
def draw_class_based_barplot(counts, values, class_map=None, bar_type="horizontal", width=500, height=500):
    """Creates a figure with a histogram."""
    if class_map is None:
        values = [str(entry) for entry in values]
    else:
        values = [class_map.get_id(entry) for entry in values]
    p = figure(width=width, height=height, y_range=values)
    if bar_type == "horizontal":
        p.hbar(y=values, left=0, right=counts, height=0.9)
    elif bar_type == "vertical":
        p.vbar(x=values, bottom=0, top=counts, width=0.9)
    else:
        raise ValueError("hist_type has to be of 'horizontal' or 'vertical'")
    return p

# Cell
def histogram(values, bins=10, range=None, density=False, plot_figure=None, remove_tools=False, width=500, height=500):
    "Creates a histogram"
    if plot_figure is None:
        p = figure(width=width, height=height)
    else:
        p = plot_figure
    counts, edges = np.histogram(values, bins=bins, range=range, density=density)
    p.quad(top=counts, bottom=0, left=edges[:-1], right=edges[1:])
    if remove_tools:
        p.toolbar.logo = None
        p.toolbar_location = None
    return p

# Cell
def time_arc_plot(start_date, end_date, plot_figure=None, width=500, height=300):
    radius = (end_date-start_date)/2
    x = start_date + radius
    if plot_figure is None:
        p = figure(x_axis_label="Date", x_axis_type='datetime', y_range=(0, radius.max()), x_range=(start_date.min(), end_date.max()), width=width, height=height)
        p.yaxis.major_tick_line_color = None
        p.yaxis.minor_tick_line_color = None
        p.yaxis.major_label_text_font_size = '0pt'
        p.toolbar.logo = None
        p.toolbar_location = None
    else:
        p = plot_figure
    p.arc(x=x, y=0, radius=radius, start_angle=0, end_angle=np.pi)
    return p

# Cell
def generate_range_filter(data, name, with_hist=True, steps=50, height=500, width=500):
    "Generates a range slider with a histogram (if with_hist is True) for a given pd.DataFrame and a column key."
    val_min = data.min()
    val_max = data.max()
    # subtract and add a bit to the min and max value to ensure the whole range is captured
    dist = val_max-val_min if val_max != val_min else 1
    val_min = val_min-0.01*dist
    val_max = val_max+0.01*dist
    slider = pnw.RangeSlider(name=name, start=val_min, end=val_max, step=round(((val_max-val_min)/steps), 1))
    if with_hist:
        hist = histogram(data, bins=20, height=100, width=int(width*0.98), remove_tools=True)
    else:
        hist = None
    range_filter = pn.Column(slider, hist, "<br>")
    return range_filter

# Cell
def get_min_and_max_dates(dates):
    min_date = dates.min().to_pydatetime().replace(microsecond=0, second=0, minute=0, hour=0)
    max_date = dates.max().to_pydatetime().replace(microsecond=0, second=0, minute=0, hour=0)
    # make sure the min and max values are at least a day appart
    if min_date == max_date:
        max_date = max_date.replace(day=max_date.day+1)
    return min_date, max_date

# Cell
def generate_creation_modification_time_filter(data, width=500, height=500):
    """Generates an arc plot with creation and modification time and two range sliders to select parts for the two."""
    plot = time_arc_plot(data["creation_date"], data["modification_date"], width=int(0.98*width))
    min_creation_date, max_creation_date = get_min_and_max_dates(data["creation_date"])
    min_modification_date, max_modification_date = get_min_and_max_dates(data["modification_date"])
    min_date = min(min_creation_date, min_modification_date)
    max_date = max(max_creation_date, max_modification_date)
    creation_time_slider = pnw.DateRangeSlider(name="Creation Time", start=min_date, end=max_date)
    modification_time_slider = pnw.DateRangeSlider(name="Modification Time", start=min_date, end=max_date)
    return pn.Column(plot, creation_time_slider, modification_time_slider)